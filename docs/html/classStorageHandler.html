<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DESIGN OF ALGORITHMS Project 1 T15_G1: StorageHandler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DESIGN OF ALGORITHMS Project 1 T15_G1
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classStorageHandler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">StorageHandler Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for handling operations related to loading data, route calculations, and batch processing.  
 <a href="classStorageHandler.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="storage_8hpp_source.html">storage.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa7cca8dc00a3182190c1a4ae7b932c82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageHandler.html#aa7cca8dc00a3182190c1a4ae7b932c82">loadLocations</a> (const std::string &amp;locationsFile)</td></tr>
<tr class="memdesc:aa7cca8dc00a3182190c1a4ae7b932c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads location data from a CSV file.  <a href="classStorageHandler.html#aa7cca8dc00a3182190c1a4ae7b932c82">More...</a><br /></td></tr>
<tr class="separator:aa7cca8dc00a3182190c1a4ae7b932c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8132a443dbcbaa104db945fcf48c6759"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageHandler.html#a8132a443dbcbaa104db945fcf48c6759">loadRoads</a> (const std::string &amp;roadFile)</td></tr>
<tr class="memdesc:a8132a443dbcbaa104db945fcf48c6759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads road data from a CSV file.  <a href="classStorageHandler.html#a8132a443dbcbaa104db945fcf48c6759">More...</a><br /></td></tr>
<tr class="separator:a8132a443dbcbaa104db945fcf48c6759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ca0808d00f2f7705c82c8c7f8c91f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageHandler.html#ad2ca0808d00f2f7705c82c8c7f8c91f4">callDijkstra</a> (const std::string &amp;source, const std::string &amp;dest)</td></tr>
<tr class="memdesc:ad2ca0808d00f2f7705c82c8c7f8c91f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls Dijkstra's algorithm to find the shortest path between two locations.  <a href="classStorageHandler.html#ad2ca0808d00f2f7705c82c8c7f8c91f4">More...</a><br /></td></tr>
<tr class="separator:ad2ca0808d00f2f7705c82c8c7f8c91f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68801f5963e41a8790e92cf1e849886b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageHandler.html#a68801f5963e41a8790e92cf1e849886b">callRestrictedDijkstra</a> (const std::string &amp;src, const std::string &amp;dest, const std::string &amp;avoidNodes, const std::string &amp;avoidSegments, const std::string &amp;includeNode)</td></tr>
<tr class="memdesc:a68801f5963e41a8790e92cf1e849886b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls Dijkstra's algorithm to find the shortest path with restrictions.  <a href="classStorageHandler.html#a68801f5963e41a8790e92cf1e849886b">More...</a><br /></td></tr>
<tr class="separator:a68801f5963e41a8790e92cf1e849886b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ae174156ecb8873785f02bf70899dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageHandler.html#a94ae174156ecb8873785f02bf70899dd">calculateEnvironmentalRoute</a> (int source, int destination, int maxWalkingTime, std::vector&lt; int &gt; avoidNodes, std::vector&lt; std::pair&lt; int, int &gt;&gt; avoidSegments)</td></tr>
<tr class="memdesc:a94ae174156ecb8873785f02bf70899dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates an environmentally friendly route that includes walking.  <a href="classStorageHandler.html#a94ae174156ecb8873785f02bf70899dd">More...</a><br /></td></tr>
<tr class="separator:a94ae174156ecb8873785f02bf70899dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9540b1b4c8d27708c37703f479319f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageHandler.html#a7a9540b1b4c8d27708c37703f479319f">parseBatchInput</a> (<a class="el" href="structData.html">Data</a> *data)</td></tr>
<tr class="memdesc:a7a9540b1b4c8d27708c37703f479319f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses input data for batch processing from a file.  <a href="classStorageHandler.html#a7a9540b1b4c8d27708c37703f479319f">More...</a><br /></td></tr>
<tr class="separator:a7a9540b1b4c8d27708c37703f479319f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9224c6457c59c350000923a8fd016488"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStorageHandler.html#a9224c6457c59c350000923a8fd016488">callBatchFunction</a> (const <a class="el" href="structData.html">Data</a> &amp;data)</td></tr>
<tr class="memdesc:a9224c6457c59c350000923a8fd016488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a batch function based on parsed data.  <a href="classStorageHandler.html#a9224c6457c59c350000923a8fd016488">More...</a><br /></td></tr>
<tr class="separator:a9224c6457c59c350000923a8fd016488"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for handling operations related to loading data, route calculations, and batch processing. </p>
<p>This class provides methods to load location and road data, calculate routes using Dijkstra's algorithm, handle batch operations, and more. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a94ae174156ecb8873785f02bf70899dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ae174156ecb8873785f02bf70899dd">&#9670;&nbsp;</a></span>calculateEnvironmentalRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageHandler::calculateEnvironmentalRoute </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxWalkingTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>avoidNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; int, int &gt;&gt;&#160;</td>
          <td class="paramname"><em>avoidSegments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates an environmentally friendly route that includes walking. </p>
<p>Calculates an environmental route from source to destination considering both driving and walking paths, with optional exclusions.</p>
<p>This function calculates a route combining both driving and walking, with the constraint of a maximum walking time and any segments or nodes to avoid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source location ID. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination location ID. </td></tr>
    <tr><td class="paramname">maxWalkingTime</td><td>Maximum allowed walking time in minutes. </td></tr>
    <tr><td class="paramname">avoidNodes</td><td>A list of node IDs to avoid. </td></tr>
    <tr><td class="paramname">avoidSegments</td><td>A list of segment pairs (id1, id2) to avoid.</td></tr>
  </table>
  </dd>
</dl>
<p>Time complexity: O(E log V), where E is the number of edges and V is the number of vertices in the graph. Similar to the standard Dijkstra algorithm with additional considerations for walking paths.</p>
<p>This function calculates the optimal route from a source to a destination while considering:</p><ul>
<li>Driving to a parking area, followed by walking to the destination.</li>
<li>The ability to exclude certain nodes (locations) and segments (edges) from the graph during the calculation.</li>
<li>The ability to filter routes based on a maximum walking time.</li>
</ul>
<p>The algorithm first excludes the requested nodes and segments from the graph, then calculates potential routes by:</p><ul>
<li>Finding a driving route from the source to a parking location.</li>
<li>Finding a walking route from that parking location to the destination.</li>
</ul>
<p>The function stores the best routes that meet the conditions in a file, and outputs them in the console. If no valid route exists, an appropriate message is printed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source node ID (integer). </td></tr>
    <tr><td class="paramname">destination</td><td>The destination node ID (integer). </td></tr>
    <tr><td class="paramname">maxWalkingTime</td><td>The maximum allowed walking time (in minutes). </td></tr>
    <tr><td class="paramname">avoidNodes</td><td>A list of node IDs to be avoided during route calculation. </td></tr>
    <tr><td class="paramname">avoidSegments</td><td>A list of edges (pairs of node IDs) to be avoided.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function calculates all possible routes that satisfy the walking time constraint and returns the best one. If no valid route is found, the output will indicate that no route is possible.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If an invalid node or edge is encountered during processing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function can be broken down as follows:<ul>
<li>Excluding nodes and segments involves iterating through the provided lists (<code>O(n)</code> complexity, where <code>n</code> is the number of nodes or segments).</li>
<li>For each parking node, two Dijkstra runs are performed:<ul>
<li>One for driving from the source to the parking node (<code>O((V + E) * log(V))</code> for the adjacency list representation).</li>
<li>One for walking from the parking node to the destination (<code>O((V + E) * log(V))</code>).</li>
</ul>
</li>
<li>Sorting and selecting the best routes involves iterating through the possible routes, which is <code>O(m * log(m))</code>, where <code>m</code> is the number of candidates.</li>
</ul>
</dd></dl>
<p>Overall, the time complexity of the function is dominated by the Dijkstra runs and sorting, making it approximately: O(m * log(m) + 2 * (V + E) * log(V)). </p>

</div>
</div>
<a id="a9224c6457c59c350000923a8fd016488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9224c6457c59c350000923a8fd016488">&#9670;&nbsp;</a></span>callBatchFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageHandler::callBatchFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structData.html">Data</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a batch function based on parsed data. </p>
<p>This function processes the batch data (from the <code><a class="el" href="structData.html" title="Structure to hold data for route calculation, including restrictions and other parameters.">Data</a></code> structure) and executes the necessary route planning functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The batch data structure containing the parsed input.</td></tr>
  </table>
  </dd>
</dl>
<p>Time complexity: O(N), where N is the number of operations or routes to process in the batch. </p>

</div>
</div>
<a id="ad2ca0808d00f2f7705c82c8c7f8c91f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ca0808d00f2f7705c82c8c7f8c91f4">&#9670;&nbsp;</a></span>callDijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageHandler::callDijkstra </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls Dijkstra's algorithm to find the shortest path between two locations. </p>
<p>Finds the shortest driving path between two locations using Dijkstra's algorithm.</p>
<p>This function invokes Dijkstra's algorithm to find the best route between the given source and destination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source location ID. </td></tr>
    <tr><td class="paramname">dest</td><td>The destination location ID.</td></tr>
  </table>
  </dd>
</dl>
<p>Time complexity: O(E log V), where E is the number of edges and V is the number of vertices in the graph.</p>
<p>This function attempts to find the shortest driving path between two locations, specified by either their vertex IDs or location codes. It first checks if the provided source and destination are numeric (IDs) or location codes (strings), and converts them accordingly. Once the valid source and destination IDs are obtained, it invokes the Dijkstra algorithm for the <code>cityGraph</code> to find the shortest path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source location, either as an ID or a location code. </td></tr>
    <tr><td class="paramname">dest</td><td>The destination location, either as an ID or a location code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If either the source or destination is invalid or not found in the graph.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function depends on the implementation of Dijkstra's algorithm:<ul>
<li>If the graph is represented as an adjacency matrix, the time complexity is O(V^2), where V is the number of vertices.</li>
<li>If the graph is represented as an adjacency list and a priority queue (min-heap) is used, the time complexity is O((V + E) * log(V)), where V is the number of vertices and E is the number of edges in the graph. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a68801f5963e41a8790e92cf1e849886b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68801f5963e41a8790e92cf1e849886b">&#9670;&nbsp;</a></span>callRestrictedDijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageHandler::callRestrictedDijkstra </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>avoidNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>avoidSegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>includeNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls Dijkstra's algorithm to find the shortest path with restrictions. </p>
<p>Finds the shortest driving path between two locations using Dijkstra's algorithm with additional restrictions.</p>
<p>This function invokes a restricted version of Dijkstra's algorithm that takes into account the provided nodes and segments to avoid and any required node to include.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source location ID. </td></tr>
    <tr><td class="paramname">dest</td><td>The destination location ID. </td></tr>
    <tr><td class="paramname">avoidNodes</td><td>A comma-separated string of node IDs to avoid. </td></tr>
    <tr><td class="paramname">avoidSegments</td><td>A comma-separated string of road segments to avoid. </td></tr>
    <tr><td class="paramname">includeNode</td><td>A string representing a node to include in the route.</td></tr>
  </table>
  </dd>
</dl>
<p>Time complexity: O(E log V), where E is the number of edges and V is the number of vertices. The complexity is similar to Dijkstra's algorithm with additional constraints.</p>
<p>This function finds the shortest driving path between two locations using Dijkstra's algorithm, with additional restrictions:</p><ul>
<li>It allows certain nodes to be avoided during the path calculation.</li>
<li>It allows certain segments (edges) to be avoided.</li>
<li>Optionally, it can require the path to pass through a specific node.</li>
</ul>
<p>The function handles both location codes (strings) and IDs (numeric), and converts them as needed. The function parses the comma-separated lists of nodes and segments to be avoided, as well as the optional node that must be included in the path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source location, either as an ID or a location code. </td></tr>
    <tr><td class="paramname">dest</td><td>The destination location, either as an ID or a location code. </td></tr>
    <tr><td class="paramname">avoidNodes</td><td>A comma-separated string of nodes to avoid (IDs). </td></tr>
    <tr><td class="paramname">avoidSegments</td><td>A comma-separated string of segments (edges) to avoid, represented as pairs of node IDs. </td></tr>
    <tr><td class="paramname">includeNode</td><td>An optional node (ID or code) that must be included in the path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If any of the specified nodes or edges are not found in the graph.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function depends on the implementation of the restricted Dijkstra algorithm:<ul>
<li>If the graph is represented as an adjacency matrix, the time complexity is O(V^2), where V is the number of vertices.</li>
<li>If the graph is represented as an adjacency list and a priority queue (min-heap) is used, the time complexity is O((V + E) * log(V)), where V is the number of vertices and E is the number of edges in the graph.</li>
<li>The additional restrictions (avoiding nodes, segments, and including a specific node) may add complexity, but the core complexity remains O((V + E) * log(V)) for an adjacency list representation. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aa7cca8dc00a3182190c1a4ae7b932c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cca8dc00a3182190c1a4ae7b932c82">&#9670;&nbsp;</a></span>loadLocations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageHandler::loadLocations </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>locationsFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads location data from a CSV file. </p>
<p>Loads locations from a CSV file.</p>
<p>This function reads location data from the specified CSV file and loads it into the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">locationsFile</td><td>Path to the locations CSV file.</td></tr>
  </table>
  </dd>
</dl>
<p>Time complexity: O(N), where N is the number of locations to load and parse from the file.</p>
<p>This function loads location data from a CSV file and adds the locations as vertices to the <code>cityGraph</code>. It parses each line of the file, extracts relevant fields (location name, ID, code, and parking status), and adds the parsed data as vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">locationsFile</td><td>The file path of the locations CSV.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the file cannot be opened or an error occurs during processing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(m * n), where m is the number of lines in the file, and n is the average number of characters per line. Each line is parsed, and for each location, the algorithm attempts to add a vertex to the graph. </dd></dl>

</div>
</div>
<a id="a8132a443dbcbaa104db945fcf48c6759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8132a443dbcbaa104db945fcf48c6759">&#9670;&nbsp;</a></span>loadRoads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StorageHandler::loadRoads </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>roadFile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads road data from a CSV file. </p>
<p>Loads roads from a CSV file.</p>
<p>This function reads road data (connections between locations) from the specified CSV file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roadFile</td><td>Path to the roads CSV file.</td></tr>
  </table>
  </dd>
</dl>
<p>Time complexity: O(M), where M is the number of roads to load and parse from the file.</p>
<p>This function loads road data from a file and adds bidirectional roads as edges between vertices in the <code>cityGraph</code>. It parses the file and handles both driving and walking road information for each road segment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">roadFile</td><td>The file path of the roads CSV.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the file cannot be opened or an error occurs during processing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this function is O(m * n), where m is the number of lines in the file, and n is the average number of characters per line. For each line, the algorithm processes road data and adds bidirectional edges to the graph. </dd></dl>

</div>
</div>
<a id="a7a9540b1b4c8d27708c37703f479319f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9540b1b4c8d27708c37703f479319f">&#9670;&nbsp;</a></span>parseBatchInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int StorageHandler::parseBatchInput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structData.html">Data</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses input data for batch processing from a file. </p>
<p>This function parses input from a file to populate the <code><a class="el" href="structData.html" title="Structure to hold data for route calculation, including restrictions and other parameters.">Data</a></code> structure for batch processing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to a <code><a class="el" href="structData.html" title="Structure to hold data for route calculation, including restrictions and other parameters.">Data</a></code> structure where parsed data will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Returns 0 if successful, non-zero if an error occurred.</dd></dl>
<p>Time complexity: O(N), where N is the number of lines or data entries to parse. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="storage_8hpp_source.html">storage.hpp</a></li>
<li>src/<a class="el" href="storage_8cpp.html">storage.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
