<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DESIGN OF ALGORITHMS Project 1 T15_G1: Graph&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DESIGN OF ALGORITHMS Project 1 T15_G1
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classGraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Graph&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classGraph.html" title="Graph class representing a graph structure.">Graph</a> class representing a graph structure.  
 <a href="classGraph.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="graph_8hpp_source.html">graph.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a43eab1460b5c8ceaa526b40e56a0fb0c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a43eab1460b5c8ceaa526b40e56a0fb0c">~Graph</a> ()</td></tr>
<tr class="memdesc:a43eab1460b5c8ceaa526b40e56a0fb0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for the <a class="el" href="classGraph.html" title="Graph class representing a graph structure.">Graph</a> class.  <a href="classGraph.html#a43eab1460b5c8ceaa526b40e56a0fb0c">More...</a><br /></td></tr>
<tr class="separator:a43eab1460b5c8ceaa526b40e56a0fb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7b7465fbfd562e2a469f90a437ab75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a8b7b7465fbfd562e2a469f90a437ab75">findVertex</a> (const T &amp;in) const</td></tr>
<tr class="memdesc:a8b7b7465fbfd562e2a469f90a437ab75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a vertex in the graph by its ID.  <a href="classGraph.html#a8b7b7465fbfd562e2a469f90a437ab75">More...</a><br /></td></tr>
<tr class="separator:a8b7b7465fbfd562e2a469f90a437ab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8fcbc064425f874884e6d24f235225"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#afd8fcbc064425f874884e6d24f235225">findVertex</a> (const std::string &amp;code) const</td></tr>
<tr class="memdesc:afd8fcbc064425f874884e6d24f235225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a vertex in the graph by its code.  <a href="classGraph.html#afd8fcbc064425f874884e6d24f235225">More...</a><br /></td></tr>
<tr class="separator:afd8fcbc064425f874884e6d24f235225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3d50b9218f06e3599e360fbd69c56b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a3c3d50b9218f06e3599e360fbd69c56b">addVertex</a> (const T &amp;in, const std::string &amp;code, bool parking)</td></tr>
<tr class="memdesc:a3c3d50b9218f06e3599e360fbd69c56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a vertex with the given ID and code to the graph.  <a href="classGraph.html#a3c3d50b9218f06e3599e360fbd69c56b">More...</a><br /></td></tr>
<tr class="separator:a3c3d50b9218f06e3599e360fbd69c56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c903104ad69a7782979fa9caedf163"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#af9c903104ad69a7782979fa9caedf163">removeVertex</a> (const T &amp;in)</td></tr>
<tr class="memdesc:af9c903104ad69a7782979fa9caedf163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a vertex with a given content from the graph, along with all its edges.  <a href="classGraph.html#af9c903104ad69a7782979fa9caedf163">More...</a><br /></td></tr>
<tr class="separator:af9c903104ad69a7782979fa9caedf163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5c26a7ba75113a2f5776f2de7d1350"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a8b5c26a7ba75113a2f5776f2de7d1350">addEdge</a> (const T &amp;source, const T &amp;dest, double w, double d)</td></tr>
<tr class="memdesc:a8b5c26a7ba75113a2f5776f2de7d1350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an edge between two vertices, with specified driving and walking times.  <a href="classGraph.html#a8b5c26a7ba75113a2f5776f2de7d1350">More...</a><br /></td></tr>
<tr class="separator:a8b5c26a7ba75113a2f5776f2de7d1350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7769cbf0d7786b40db8568bdc7517505"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a7769cbf0d7786b40db8568bdc7517505">addEdge</a> (const std::string &amp;source, const std::string &amp;dest, double w, double d)</td></tr>
<tr class="memdesc:a7769cbf0d7786b40db8568bdc7517505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a directed edge to the graph between two existing vertices.  <a href="classGraph.html#a7769cbf0d7786b40db8568bdc7517505">More...</a><br /></td></tr>
<tr class="separator:a7769cbf0d7786b40db8568bdc7517505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8949d071d45bf93e171e275462e1007a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a8949d071d45bf93e171e275462e1007a">removeEdge</a> (const T &amp;source, const T &amp;dest)</td></tr>
<tr class="memdesc:a8949d071d45bf93e171e275462e1007a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a directed edge from the graph.  <a href="classGraph.html#a8949d071d45bf93e171e275462e1007a">More...</a><br /></td></tr>
<tr class="separator:a8949d071d45bf93e171e275462e1007a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c1f7157ba0345e0cd018e39bb07c00"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a34c1f7157ba0345e0cd018e39bb07c00">addBidirectionalEdge</a> (const T &amp;source, const T &amp;dest, double w, double d)</td></tr>
<tr class="memdesc:a34c1f7157ba0345e0cd018e39bb07c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a bidirectional edge between two vertices, with specified driving and walking times.  <a href="classGraph.html#a34c1f7157ba0345e0cd018e39bb07c00">More...</a><br /></td></tr>
<tr class="separator:a34c1f7157ba0345e0cd018e39bb07c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d4ec0d3110e11a25da89674e960558"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a63d4ec0d3110e11a25da89674e960558">addBidirectionalEdge</a> (const std::string &amp;source, const std::string &amp;dest, double w, double d)</td></tr>
<tr class="memdesc:a63d4ec0d3110e11a25da89674e960558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a bidirectional (undirected) edge between two vertices, identified by their string identifiers.  <a href="classGraph.html#a63d4ec0d3110e11a25da89674e960558">More...</a><br /></td></tr>
<tr class="separator:a63d4ec0d3110e11a25da89674e960558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0853eac15cdf0f06d63f4b8a7820ec71"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a0853eac15cdf0f06d63f4b8a7820ec71">getNumVertex</a> () const</td></tr>
<tr class="memdesc:a0853eac15cdf0f06d63f4b8a7820ec71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of vertices in the graph.  <a href="classGraph.html#a0853eac15cdf0f06d63f4b8a7820ec71">More...</a><br /></td></tr>
<tr class="separator:a0853eac15cdf0f06d63f4b8a7820ec71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41624b03fcb6bd29e4df574a1ec58541"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a41624b03fcb6bd29e4df574a1ec58541">getVertexSet</a> () const</td></tr>
<tr class="memdesc:a41624b03fcb6bd29e4df574a1ec58541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves all vertices in the graph.  <a href="classGraph.html#a41624b03fcb6bd29e4df574a1ec58541">More...</a><br /></td></tr>
<tr class="separator:a41624b03fcb6bd29e4df574a1ec58541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc31add72156f352131508c01ff2d27b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#afc31add72156f352131508c01ff2d27b">fastestDrivingPathWithAlt</a> (const T &amp;origin, const T &amp;destination)</td></tr>
<tr class="memdesc:afc31add72156f352131508c01ff2d27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the fastest driving path with alternative routes.  <a href="classGraph.html#afc31add72156f352131508c01ff2d27b">More...</a><br /></td></tr>
<tr class="separator:afc31add72156f352131508c01ff2d27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a9cf04cf54c5e5b1624a763d068d34"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classEdge.html">Edge</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#af0a9cf04cf54c5e5b1624a763d068d34">dijkstraDriving</a> (const T &amp;origin, const T &amp;destination)</td></tr>
<tr class="memdesc:af0a9cf04cf54c5e5b1624a763d068d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the shortest path for driving using Dijkstra's algorithm.  <a href="classGraph.html#af0a9cf04cf54c5e5b1624a763d068d34">More...</a><br /></td></tr>
<tr class="separator:af0a9cf04cf54c5e5b1624a763d068d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a47e200d83ea6ded6f0d28a8a90a11"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classEdge.html">Edge</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a06a47e200d83ea6ded6f0d28a8a90a11">dijkstraWalking</a> (const T &amp;origin, const T &amp;destination)</td></tr>
<tr class="memdesc:a06a47e200d83ea6ded6f0d28a8a90a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the shortest path for walking using Dijkstra's algorithm.  <a href="classGraph.html#a06a47e200d83ea6ded6f0d28a8a90a11">More...</a><br /></td></tr>
<tr class="separator:a06a47e200d83ea6ded6f0d28a8a90a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc04f1167b560db2fda91642dbd14f0f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#abc04f1167b560db2fda91642dbd14f0f">getAllParkingVertices</a> () const</td></tr>
<tr class="memdesc:abc04f1167b560db2fda91642dbd14f0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves all vertices in the graph that have parking.  <a href="classGraph.html#abc04f1167b560db2fda91642dbd14f0f">More...</a><br /></td></tr>
<tr class="separator:abc04f1167b560db2fda91642dbd14f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bae6b1462cc5bc3f764a5bda6dac73d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a6bae6b1462cc5bc3f764a5bda6dac73d">fastestRestrictedDrivingPath</a> (const T &amp;origin, const T &amp;destination, std::vector&lt; T &gt; avoidNodes, std::vector&lt; std::pair&lt; T, T &gt;&gt; avoidSegments, std::optional&lt; T &gt; stop)</td></tr>
<tr class="memdesc:a6bae6b1462cc5bc3f764a5bda6dac73d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the fastest restricted driving path with conditions.  <a href="classGraph.html#a6bae6b1462cc5bc3f764a5bda6dac73d">More...</a><br /></td></tr>
<tr class="separator:a6bae6b1462cc5bc3f764a5bda6dac73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a8b3c1e035c9883d16ad135b0966f97c2"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; int, <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a8b3c1e035c9883d16ad135b0966f97c2">idToVertexMap</a></td></tr>
<tr class="separator:a8b3c1e035c9883d16ad135b0966f97c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b270485bd852e944302d7420fa9f824"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a4b270485bd852e944302d7420fa9f824">codeToVertexMap</a></td></tr>
<tr class="separator:a4b270485bd852e944302d7420fa9f824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4517f4351bc7f0348369b25b7c0b44fe"><td class="memItemLeft" align="right" valign="top">double **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#a4517f4351bc7f0348369b25b7c0b44fe">distMatrix</a> = nullptr</td></tr>
<tr class="separator:a4517f4351bc7f0348369b25b7c0b44fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9524726f8f3cda3115a0d03e3f6e09"><td class="memItemLeft" align="right" valign="top">int **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGraph.html#afb9524726f8f3cda3115a0d03e3f6e09">pathMatrix</a> = nullptr</td></tr>
<tr class="separator:afb9524726f8f3cda3115a0d03e3f6e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class Graph&lt; T &gt;</h3>

<p><a class="el" href="classGraph.html" title="Graph class representing a graph structure.">Graph</a> class representing a graph structure. </p>
<p>This class manages a collection of vertices and edges, supporting various graph algorithms such as Dijkstra's, and providing methods for adding/removing vertices and edges, as well as performing graph traversals and shortest path calculations. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a43eab1460b5c8ceaa526b40e56a0fb0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43eab1460b5c8ceaa526b40e56a0fb0c">&#9670;&nbsp;</a></span>~Graph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::~<a class="el" href="classGraph.html">Graph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor for the <a class="el" href="classGraph.html" title="Graph class representing a graph structure.">Graph</a> class. </p>
<ul>
<li>Frees memory allocated for the distance and path matrices.</li>
<li>The number of rows in each matrix is equal to the number of vertices.</li>
<li>Each row contains an array of pointers, leading to a total complexity of <b>O(V)</b> for deallocation. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a63d4ec0d3110e11a25da89674e960558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d4ec0d3110e11a25da89674e960558">&#9670;&nbsp;</a></span>addBidirectionalEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::addBidirectionalEdge </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sourc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a bidirectional (undirected) edge between two vertices, identified by their string identifiers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourc</td><td>The unique identifier (string) of the first vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>The unique identifier (string) of the second vertex. </td></tr>
    <tr><td class="paramname">w</td><td>The weight (walking time) of the edge. </td></tr>
    <tr><td class="paramname">d</td><td>The driving time of the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the edge was successfully added, <code>false</code> if either vertex does not exist.</dd></dl>
<ul>
<li>Finding both vertices takes <b>O(1)</b> on average.</li>
<li>Adding an edge to both adjacency lists takes <b>O(1)</b>.</li>
<li>Setting the reverse edge pointers takes <b>O(1)</b>.</li>
<li>Overall, the expected time complexity is <b>O(1)</b>. </li>
</ul>

</div>
</div>
<a id="a34c1f7157ba0345e0cd018e39bb07c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c1f7157ba0345e0cd018e39bb07c00">&#9670;&nbsp;</a></span>addBidirectionalEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::addBidirectionalEdge </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>sourc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a bidirectional edge between two vertices, with specified driving and walking times. </p>
<p>Adds a bidirectional (undirected) edge between two vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source vertex ID. </td></tr>
    <tr><td class="paramname">dest</td><td>The destination vertex ID. </td></tr>
    <tr><td class="paramname">w</td><td>The driving time weight. </td></tr>
    <tr><td class="paramname">d</td><td>The walking time weight.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the bidirectional edge was successfully added, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function runs in O(1) time as it adds two edges (one for each direction) to the graph.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourc</td><td>The unique identifier of the first vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>The unique identifier of the second vertex. </td></tr>
    <tr><td class="paramname">w</td><td>The weight (walking time) of the edge. </td></tr>
    <tr><td class="paramname">d</td><td>The driving time of the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the edge was successfully added, <code>false</code> if either vertex does not exist.</dd></dl>
<ul>
<li>Finding both vertices takes <b>O(1)</b> on average.</li>
<li>Adding an edge to both adjacency lists takes <b>O(1)</b>.</li>
<li>Setting the reverse edge pointers takes <b>O(1)</b>.</li>
<li>Overall, the expected time complexity is <b>O(1)</b>. </li>
</ul>

</div>
</div>
<a id="a7769cbf0d7786b40db8568bdc7517505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7769cbf0d7786b40db8568bdc7517505">&#9670;&nbsp;</a></span>addEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::addEdge </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sourc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a directed edge to the graph between two existing vertices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourc</td><td>The unique identifier of the source vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>The unique identifier of the destination vertex. </td></tr>
    <tr><td class="paramname">w</td><td>The weight (walking time) of the edge. </td></tr>
    <tr><td class="paramname">d</td><td>The driving time of the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the edge was successfully added, <code>false</code> if either vertex does not exist.</dd></dl>
<ul>
<li>Finding both source and destination vertices takes <b>O(1)</b> on average.</li>
<li>Adding an edge to the adjacency list of the source vertex takes <b>O(1)</b>.</li>
<li>Overall, the expected time complexity is <b>O(1)</b>. </li>
</ul>

</div>
</div>
<a id="a8b5c26a7ba75113a2f5776f2de7d1350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5c26a7ba75113a2f5776f2de7d1350">&#9670;&nbsp;</a></span>addEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::addEdge </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>sourc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds an edge between two vertices, with specified driving and walking times. </p>
<p>Adds an edge to the graph between two existing vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source vertex ID. </td></tr>
    <tr><td class="paramname">dest</td><td>The destination vertex ID. </td></tr>
    <tr><td class="paramname">w</td><td>The driving time weight. </td></tr>
    <tr><td class="paramname">d</td><td>The walking time weight.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the edge was successfully added, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function runs in O(1) time, as it involves inserting the edge into the adjacency list.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourc</td><td>The identifier of the source vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>The identifier of the destination vertex. </td></tr>
    <tr><td class="paramname">w</td><td>The weight (walking time) of the edge. </td></tr>
    <tr><td class="paramname">d</td><td>The driving time of the edge. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the edge was successfully added, <code>false</code> if either vertex does not exist.</dd></dl>
<ul>
<li>Finding both source and destination vertices takes <b>O(1)</b> on average.</li>
<li>Adding an edge to the adjacency list of the source vertex takes <b>O(1)</b>.</li>
<li>Overall, the expected time complexity is <b>O(1)</b>. </li>
</ul>

</div>
</div>
<a id="a3c3d50b9218f06e3599e360fbd69c56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c3d50b9218f06e3599e360fbd69c56b">&#9670;&nbsp;</a></span>addVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::addVertex </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a vertex with the given ID and code to the graph. </p>
<p>Adds a vertex with a given identifier, unique code, and parking information to the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The ID of the vertex. </td></tr>
    <tr><td class="paramname">code</td><td>The code associated with the vertex. </td></tr>
    <tr><td class="paramname">parking</td><td>Indicates whether the vertex has parking.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the vertex was successfully added, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function runs in O(1) time, as it only involves inserting into a hash map.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The unique identifier of the vertex. </td></tr>
    <tr><td class="paramname">code</td><td>The unique code of the vertex. </td></tr>
    <tr><td class="paramname">parking</td><td>Boolean indicating whether the vertex has parking. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the vertex was successfully added, <code>false</code> if a vertex with the given identifier already exists.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>- Checking for existence in <code>idToVertexMap</code> runs in <b>O(1)</b> average time complexity.<ul>
<li>Insertion into both <code>idToVertexMap</code> and <code>codeToVertexMap</code> also runs in <b>O(1)</b> on average.</li>
<li>Worst case complexity (due to hash collisions) is <b>O(V)</b>.</li>
<li>Overall, the expected time complexity is <b>O(1)</b>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="af0a9cf04cf54c5e5b1624a763d068d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a9cf04cf54c5e5b1624a763d068d34">&#9670;&nbsp;</a></span>dijkstraDriving()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classEdge.html">Edge</a>&lt; T &gt; * &gt; <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::dijkstraDriving </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the shortest path for driving using Dijkstra's algorithm. </p>
<p>Computes the shortest driving path from <code>origin</code> to <code>destination</code> using Dijkstra’s Algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The starting vertex. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of edges representing the shortest driving path.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function runs in O((V + E) * log(V)) where V is the number of vertices and E is the number of edges.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The starting vertex. </td></tr>
    <tr><td class="paramname">destination</td><td>The target vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Edge&lt;T&gt;*&gt; The list of edges representing the shortest path.</dd></dl>
<ul>
<li>Initializes all vertex distances to <b>infinity (INF)</b>.</li>
<li>Uses a <b>min-heap (priority queue)</b> for efficient extraction of the next closest vertex.</li>
<li>Updates the shortest paths dynamically as it explores neighbors.</li>
<li>Returns the <b>sequence of edges</b> forming the optimal path from <code>origin</code> to <code>destination</code>.</li>
<li>If no path is found, returns an empty vector.</li>
</ul>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>origin</code> or <code>destination</code> do not exist.</td></tr>
  </table>
  </dd>
</dl>
<p>@complexity</p><ul>
<li><b>Priority Queue Operations:</b> O(log V) per insertion/extraction.</li>
<li><b>Total Complexity:</b> O((V + E) log V). </li>
</ul>

</div>
</div>
<a id="a06a47e200d83ea6ded6f0d28a8a90a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a47e200d83ea6ded6f0d28a8a90a11">&#9670;&nbsp;</a></span>dijkstraWalking()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classEdge.html">Edge</a>&lt; T &gt; * &gt; <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::dijkstraWalking </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the shortest path for walking using Dijkstra's algorithm. </p>
<p>Computes the shortest walking path between two vertices using Dijkstra's algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The starting vertex. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of edges representing the shortest walking path.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function runs in O((V + E) * log(V)) where V is the number of vertices and E is the number of edges.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The starting vertex. </td></tr>
    <tr><td class="paramname">destination</td><td>The target vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Edge&lt;T&gt;*&gt; A vector representing the shortest path edges in order.</dd></dl>
<ul>
<li>Uses a <b>priority queue (min-heap)</b> to efficiently process vertices in increasing distance order.</li>
<li>Initializes all vertex distances to <b>infinity (INF)</b> and resets their paths.</li>
<li>Extracts the vertex with the smallest distance, updating its neighbors accordingly.</li>
<li>Stops early if the destination is reached.</li>
<li>Returns a vector of edges forming the shortest walking path.</li>
</ul>
<p>@complexity</p><ul>
<li><b>Priority queue operations (O(log V))</b> per vertex.</li>
<li><b>Each edge is processed once (O(E log V))</b>.</li>
<li><b>Overall Complexity:</b> <b>O((V + E) log V)</b>. </li>
</ul>

</div>
</div>
<a id="afc31add72156f352131508c01ff2d27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc31add72156f352131508c01ff2d27b">&#9670;&nbsp;</a></span>fastestDrivingPathWithAlt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::fastestDrivingPathWithAlt </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the fastest driving path with alternative routes. </p>
<p>Finds the fastest driving path and an alternative path using Dijkstra’s algorithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The starting vertex. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function may run in O((V + E) * log(V)) depending on the algorithm used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The starting point of the route. </td></tr>
    <tr><td class="paramname">destination</td><td>The endpoint of the route.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Uses <b>Dijkstra’s algorithm</b> to find the shortest driving path from <code>origin</code> to <code>destination</code>.</li>
<li>Stores the best route in <code>usedRoads</code>.</li>
<li>If a valid path exists:<ul>
<li>Marks edges as unavailable.</li>
<li>Runs Dijkstra again to find an <b>alternative route</b> (if possible).</li>
<li>Restores edges after computation.</li>
</ul>
</li>
<li>Outputs results to both <b>console</b> and <b>file</b>.</li>
</ul>
<p>@complexity</p><ul>
<li><b>Dijkstra’s Algorithm Complexity:</b> O((V + E) log V) for each run.</li>
<li><b>Setting <a class="el" href="classEdge.html" title="Edge class representing an edge between two vertices.">Edge</a> Availability:</b> O(E) (each edge in the best path is updated).</li>
<li><b>Total Complexity:</b> O((V + E) log V). </li>
</ul>

</div>
</div>
<a id="a6bae6b1462cc5bc3f764a5bda6dac73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bae6b1462cc5bc3f764a5bda6dac73d">&#9670;&nbsp;</a></span>fastestRestrictedDrivingPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::fastestRestrictedDrivingPath </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>avoidNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; T, T &gt;&gt;&#160;</td>
          <td class="paramname"><em>avoidSegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::optional&lt; T &gt;&#160;</td>
          <td class="paramname"><em>stop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the fastest restricted driving path with conditions. </p>
<p>Finds the fastest restricted driving path from origin to destination, optionally passing through a stop point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The starting vertex. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination vertex. </td></tr>
    <tr><td class="paramname">avoidNodes</td><td>A list of nodes to avoid. </td></tr>
    <tr><td class="paramname">avoidSegments</td><td>A list of segments to avoid. </td></tr>
    <tr><td class="paramname">stop</td><td>An optional vertex to stop at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function may run in O((V + E) * log(V)) depending on the algorithm used.</dd></dl>
<p>This function computes the fastest restricted driving path from an origin to a destination vertex. It considers avoiding specific nodes and segments, which are excluded from the path. The function can also handle an optional stop node that the path should pass through. The function uses Dijkstra's algorithm for finding the shortest paths between the origin, stop, and destination, and excludes certain edges during the process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The origin vertex. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination vertex. </td></tr>
    <tr><td class="paramname">avoidNodes</td><td>A list of vertices to be excluded from the path. </td></tr>
    <tr><td class="paramname">avoidSegments</td><td>A list of edges (represented as pairs of vertices) to be excluded from the path. </td></tr>
    <tr><td class="paramname">stop</td><td>An optional stop vertex that the path must pass through. If no stop is provided, the path is calculated directly from origin to destination.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void This function doesn't return any value, but it outputs the result (path) to the standard output and a file.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function modifies the availability status of vertices and edges based on the provided <code>avoidNodes</code> and <code>avoidSegments</code>. It restores the availability status of the affected vertices and edges after computation.</dd></dl>
<p>@complexity</p><ul>
<li>Excluding nodes and segments: O(N * E), where N is the number of nodes (vertices) and E is the number of edges.</li>
<li>Dijkstra’s algorithm: O((V + E) log V) for each call, where V is the number of vertices and E is the number of edges.</li>
<li>The total complexity is therefore approximately O(N * E + 3 * (V + E) log V), where:<ul>
<li>N is the number of vertices in the avoidNodes list.</li>
<li>E is the number of edges in the avoidSegments list.</li>
<li>V and E represent the total number of vertices and edges in the graph. </li>
</ul>
</li>
</ul>

</div>
</div>
<a id="afd8fcbc064425f874884e6d24f235225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8fcbc064425f874884e6d24f235225">&#9670;&nbsp;</a></span>findVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::findVertex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a vertex in the graph by its code. </p>
<p>Finds a vertex in the graph given its unique code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>The code of the vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the vertex with the given code, or nullptr if not found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function runs in O(1) time, as it uses a hash map for constant time lookups.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>The unique code of the vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the vertex if found, otherwise <code>nullptr</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>find</code> operation on an unordered map runs in <b>O(1)</b> average time complexity, but in the worst case (due to hash collisions), it can be <b>O(V)</b>. </dd></dl>

</div>
</div>
<a id="a8b7b7465fbfd562e2a469f90a437ab75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b7b7465fbfd562e2a469f90a437ab75">&#9670;&nbsp;</a></span>findVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::findVertex </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds a vertex in the graph by its ID. </p>
<p>Finds a vertex in the graph given its identifier.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The ID of the vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the vertex with the given ID, or nullptr if not found.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function runs in O(1) time, as it uses a hash map for constant time lookups.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The identifier of the vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the vertex if found, otherwise <code>nullptr</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <code>find</code> operation on an unordered map runs in <b>O(1)</b> average time complexity, but in the worst case (highly unlikely due to hashing), it can be <b>O(V)</b>. </dd></dl>

</div>
</div>
<a id="abc04f1167b560db2fda91642dbd14f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc04f1167b560db2fda91642dbd14f0f">&#9670;&nbsp;</a></span>getAllParkingVertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt; <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::getAllParkingVertices</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves all vertices in the graph that have parking. </p>
<p>Retrieves all vertices that have parking available.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of vertices with parking.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function runs in O(V) time.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;Vertex&lt;T&gt;*&gt; A vector containing pointers to all vertices with parking.</dd></dl>
<ul>
<li>Iterates through the <code>idToVertexMap</code>, checking if each vertex has parking.</li>
<li>If a vertex has parking (<code>hasParking() == true</code>), it is added to the result vector.</li>
<li>Returns a list of all parking vertices.</li>
</ul>
<p>@complexity</p><ul>
<li><b>Iteration over all vertices:</b> O(V)</li>
<li><b>Total Complexity:</b> O(V) </li>
</ul>

</div>
</div>
<a id="a0853eac15cdf0f06d63f4b8a7820ec71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0853eac15cdf0f06d63f4b8a7820ec71">&#9670;&nbsp;</a></span>getNumVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::getNumVertex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of vertices in the graph. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of vertices.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function runs in O(1) time.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The total number of vertices in the graph.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Since <code>idToVertexMap.size()</code> is a constant-time operation, the time complexity is <b>O(1)</b>. </dd></dl>

</div>
</div>
<a id="a41624b03fcb6bd29e4df574a1ec58541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41624b03fcb6bd29e4df574a1ec58541">&#9670;&nbsp;</a></span>getVertexSet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classVertex.html">Vertex</a>&lt; T &gt; * &gt; <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::getVertexSet</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves all vertices in the graph. </p>
<p>Retrieves a vector containing all the vertices in the graph.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of pointers to all vertices.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function runs in O(V) time, where V is the number of vertices in the graph.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of pointers to all the vertices in the graph.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Iterating through all elements in <code>idToVertexMap</code> and inserting them into a vector takes <b>O(V)</b> time, where V is the number of vertices in the graph. </dd></dl>

</div>
</div>
<a id="a8949d071d45bf93e171e275462e1007a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8949d071d45bf93e171e275462e1007a">&#9670;&nbsp;</a></span>removeEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::removeEdge </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>sourc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a directed edge from the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourc</td><td>The unique identifier of the source vertex. </td></tr>
    <tr><td class="paramname">dest</td><td>The unique identifier of the destination vertex. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the edge was successfully removed, <code>false</code> if either the source vertex does not exist or the edge does not exist.</dd></dl>
<ul>
<li>Finding the source vertex takes <b>O(1)</b> on average.</li>
<li>Removing the edge from the adjacency list of the source vertex takes <b>O(E')</b>, where <b>E'</b> is the number of edges originating from <code>sourc</code>.</li>
<li>Overall, the worst-case time complexity is <b>O(E')</b>. </li>
</ul>

</div>
</div>
<a id="af9c903104ad69a7782979fa9caedf163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c903104ad69a7782979fa9caedf163">&#9670;&nbsp;</a></span>removeVertex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::removeVertex </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a vertex with a given content from the graph, along with all its edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The unique identifier of the vertex to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the vertex was successfully removed, <code>false</code> if the vertex does not exist.</dd></dl>
<ul>
<li>First, the function checks for the vertex in <b>O(1)</b> average time (unordered_map lookup).</li>
<li><code>removeOutGoingEdges()</code> iterates over the adjacency list and removes all outgoing edges. This takes <b>O(E')</b>, where <b>E'</b> is the number of edges originating from the vertex.</li>
<li>The loop over <code>getIncoming()</code> removes each incoming edge from the origin vertices. Since each removal operation is <b>O(E'')</b>, where <b>E''</b> is the number of incoming edges, this loop runs in <b>O(E'')</b>.</li>
<li>Erasing the vertex from the maps is <b>O(1)</b>.</li>
<li>Overall, the complexity is <b>O(E') + O(E'') ≈ O(E)</b> in the worst case. </li>
</ul>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4b270485bd852e944302d7420fa9f824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b270485bd852e944302d7420fa9f824">&#9670;&nbsp;</a></span>codeToVertexMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, <a class="el" href="classVertex.html">Vertex</a>&lt;T&gt;*&gt; <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::codeToVertexMap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4517f4351bc7f0348369b25b7c0b44fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4517f4351bc7f0348369b25b7c0b44fe">&#9670;&nbsp;</a></span>distMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double** <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::distMatrix = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b3c1e035c9883d16ad135b0966f97c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b3c1e035c9883d16ad135b0966f97c2">&#9670;&nbsp;</a></span>idToVertexMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;int, <a class="el" href="classVertex.html">Vertex</a>&lt;T&gt;*&gt; <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::idToVertexMap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb9524726f8f3cda3115a0d03e3f6e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9524726f8f3cda3115a0d03e3f6e09">&#9670;&nbsp;</a></span>pathMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int** <a class="el" href="classGraph.html">Graph</a>&lt; T &gt;::pathMatrix = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="graph_8hpp_source.html">graph.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
